using System.Collections.Immutable;

namespace CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration;

[Generator]
public class StronglyTypedIdGenerator : IIncrementalGenerator
{
	internal const string AttributeNamespace	= "CodeChops.DomainDrivenDesign.DomainModeling.Attributes";
	internal const string AttributeName			= "GenerateStronglyTypedId";
	internal const string EntityNamespace		= "CodeChops.DomainDrivenDesign.DomainModeling";
	internal const string EntityName			= "Entity";
	internal const string IdName				= "Identity";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{		
		var valueProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: SyntaxReceiver.CheckIfProbablyNeedsStronglyTypedId,
				transform: SyntaxReceiver.GetModel)
			.Where(static model => model is not null)
			.Collect();
		
		context.RegisterSourceOutput(source: valueProvider, action: CreateSource!);
	}
	
	private static void CreateSource(SourceProductionContext context, ImmutableArray<DataModel> models)
	{
		foreach (var model in models)
		{
			var code = CreateSource(model);

			var fileName = model.Namespace is null 
				? model.Name 
				: $"{model.Namespace}.{model.Name}";
			
			context.AddSource($"{fileName}Id.g.cs", SourceText.From(code, Encoding.UTF8));
		}
	}

	private static string CreateSource(DataModel data)
	{
		var className = $"{data.Name}{data.GenericTypeParameters}";

		var code = $@"// <auto-generated />
#nullable enable
using System;
using CodeChops.DomainDrivenDesign.DomainModeling.Identities;

{GetNamespaceDeclaration()}

{GetClassDeclaration()}
{{	
	{GetIdPropertyCreation()}
	{GetIdObjectCreation()}
	{GetEqualityComparison()}
}}

#nullable restore
";

		return code;
		
		// Creates the namespace definition of the location of the enum definition (or null if the namespace is not defined).
		string? GetNamespaceDeclaration()
		{
			if (data.Namespace is null) return null;

			var code = $@"namespace {data.Namespace};";
			return code;
		}

		string GetClassDeclaration()
		{
			var iHasIdImplementation = data.GenerationMethod == GenerationMethod.EntityBase
				? null
				: $": IHasId<{className}.{IdName}>";
			
			var code = $"{data.Declaration} {className} {iHasIdImplementation}";
			return code;
		}
		
		string? GetIdObjectCreation()
		{
			if (data.GenerationMethod == GenerationMethod.EntityBase)
				return null;
			
			var code = $@"
	public partial record {IdName} : global::CodeChops.DomainDrivenDesign.DomainModeling.Identities.Id<{IdName}, {data.IdIntegralType}> 
	{{ 
		public {IdName}({data.IdIntegralType} value) : base(value) {{ }}
		public {IdName}() : base() {{ }}
	}}
";

			return code;
		}

		string GetIdPropertyCreation()
		{
			if (data.GenerationMethod == GenerationMethod.EntityBase)
			{
				return @"
	public abstract Id Id { get; }
";
			}

			var code = $@"
	public {(data.GenerationMethod == GenerationMethod.EntityImplementation ? "override " : "")}{IdName} Id {{ get; }} = new();
";

			return code;
		}

		string GetEqualityComparison()
		{
			if (data.GenerationMethod is GenerationMethod.EntityImplementation or GenerationMethod.Record)
				return "";
					
			var code = @$"
	public sealed override int GetHashCode()
	{{
		return this.Id.HasDefaultValue
			? HashCode.Combine(this)
			: this.Id.GetHashCode();
	}}
	
	public sealed override bool Equals(object? obj)
	{{
		return obj is {className} other 
		       && obj.GetType() == this.GetType() 
		       && this.Equals(other);
	}}

	public bool Equals({className}? other)
	{{
		if (other is null) return false;
		if (ReferenceEquals(this, other)) return true;
		if (other.GetType() != this.GetType()) return false;
		
		return !this.Id.HasDefaultValue && this.Id.Equals(other.Id);
	}}";

			return code;
		}
		
	}
}
