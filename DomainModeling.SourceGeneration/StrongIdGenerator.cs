using System.Collections.Immutable;

namespace CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration;

[Generator]
public class StrongIdGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{		
		var valueProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: SyntaxReceiver.CheckIfIsProbablyEntity,
				transform: SyntaxReceiver.GetEntityModel)
			.Where(static entity => entity is not null)
			.Collect();
		
		context.RegisterSourceOutput(source: valueProvider, action: CreateSource!);
	}
	
	private static void CreateSource(SourceProductionContext context, ImmutableArray<EntityModel> entities)
	{
		foreach (var entity in entities)
		{
			var code = CreateSource(entity);

			var fileName = entity.Namespace is null 
				? entity.Name 
				: $"{entity.Namespace}.{entity.Name}";
			
			context.AddSource($"{fileName}.g.cs", SourceText.From(code, Encoding.UTF8));
		}
	}

	private static string CreateSource(EntityModel entity)
	{
		var className = entity.Name;

		var idName = $"{className}Id";
		var code = $@"// <auto-generated />
#nullable enable
using System;
{GetNamespaceDeclaration()}

{entity.Declaration} {className}
{{
	public override {idName} Id {{ get; }} = new();

	public partial record {idName} : global::CodeChops.DomainDrivenDesign.DomainModeling.Identities.Id<{idName}, {entity.IdIntegralType}> 
	{{ 
		public {idName}({entity.IdIntegralType} value) : base(value) {{ }}
		public {idName}() : base() {{ }}
	}}
}}

#nullable restore
";

		return code;
		
		
		// Creates the namespace definition of the location of the enum definition (or null if the namespace is not defined).
		string? GetNamespaceDeclaration()
		{
			if (entity.Namespace is null) return null;

			var code = $@"namespace {entity.Namespace};";
			return code;
		}
	}
}
