using System.Collections.Immutable;
using CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration.ValueObjectsGenerator.Models;
using CodeChops.SourceGeneration.Utilities;
using Microsoft.CodeAnalysis.Diagnostics;

namespace CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration.ValueObjectsGenerator;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{		
		var valueProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: ValueObjectSyntaxReceiver.CheckIfProbablyIsValueObjectToGenerate,
				transform: static (context, _) => ValueObjectSyntaxReceiver.GetModel((TypeDeclarationSyntax)context.Node, context.SemanticModel))
			.Where(static model => model is not null)
			.Collect()
			.Combine(context.AnalyzerConfigOptionsProvider);
		
		context.RegisterSourceOutput(source: valueProvider, action: static (context, valueProvider) => CreateSource(context, valueProvider.Left!, valueProvider.Right));
	}
	
	private static void CreateSource(SourceProductionContext context, ImmutableArray<ValueObjectBase> models, AnalyzerConfigOptionsProvider configOptionsProvider)
	{
		foreach (var model in models)
		{
			var code = CreateSource(model);

			var fileName = model.Namespace is null 
				? model.Name 
				: $"{model.Namespace}.{model.Name}";
			
			fileName = FileNameHelpers.GetFileName(fileName, configOptionsProvider);
			
			context.AddSource(fileName, SourceText.From(code, Encoding.UTF8));
		}
	}

	private static string CreateSource(ValueObjectBase valueObject)
	{
		var code = $@"// <auto-generated />
#nullable enable
#pragma warning disable CS0612

using System;
using System.Collections;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.RegularExpressions;
using CodeChops.DomainDrivenDesign.DomainModeling.Exceptions;
using CodeChops.DomainDrivenDesign.DomainModeling.Validation;
{valueObject.GetNamespaces()}

{GetNamespaceDeclaration()}

/// <summary>
/// {valueObject.GetCommentsCode()}
/// </summary>
{valueObject.Declaration} : IValueObject{GetInterfaces()}
{{
	{GetToString()}
	
	{valueObject.GetHashCodeCode()}

	{valueObject.GetEqualsCode()}

	{valueObject.GetCompareToCode()}
	
	{GetEmptyInstance()}
	
{GetProperty()}
	
	{valueObject.GetLengthOrCountCode()}
	
	public static implicit operator {valueObject.TypeName}({valueObject.Name} obj) => obj.{valueObject.PropertyName};
	public static explicit operator {valueObject.Name}({valueObject.TypeName} {valueObject.LocalVariableName}) => new({valueObject.LocalVariableName});

	public {valueObject.Name}({valueObject.TypeName} {valueObject.LocalVariableName})
	{{	
		this.{valueObject.BackingFieldName} = {valueObject.LocalVariableName};
	}}

	{GetParameterlessConstructor()}	

	{GetEnumerator()}

	{valueObject.GetExtraCode()}
}}

#pragma warning restore CS0612
#nullable restore
";

		return code;


		string? GetNamespaceDeclaration() => valueObject.Namespace is null 
			? null 
			: $@"namespace {valueObject.Namespace};";

		
		string GetInterfaces()
		{
			var interfaces = new StringBuilder();
			if (valueObject.AddCustomValidation) interfaces.Append($", IHasCustomValidation");
			if (valueObject.GenerateEmptyStatic) interfaces.Append($", IHasEmptyInstance<{valueObject.Name}>");
			if (valueObject.GenerateComparable) interfaces.Append($", IComparable<{valueObject.Name}>");

			var extraInterfaces = valueObject.GetInterfacesCode();
			if (extraInterfaces is not null) interfaces.Append($", {extraInterfaces}");
			return interfaces.ToString();
		}
		
		
		string? GetToString() => valueObject.GenerateToString ? valueObject.GetToStringCode() : null;

		
		string? GetEmptyInstance() => valueObject.GenerateEmptyStatic
			? $"public static {valueObject.Name} Empty {{ get; }} = {valueObject.GetDefaultValue()}"
			: null;

		
		string? GetParameterlessConstructor() => valueObject.ProhibitParameterlessConstruction
			? $@"
	[Obsolete(Error)]
	public {valueObject.Name}() => throw new InvalidOperationException(Error);
	private const string Error = $""A value should be provided when initializing {valueObject.Name}."";"
			: null;

		
		string GetProperty()
		{
			var callValidation = valueObject.AddCustomValidation ? "this.Validate();" : null;
			
			return $@"	
	/// <summary>
    /// The primitive structural value. Use the primary constructor to set the backing field.
    /// </summary>
	private {valueObject.TypeName} {valueObject.PropertyName} 
	{{
		get => this.{valueObject.BackingFieldName};
		init 
		{{ 
{valueObject.GetValidationCode()}
			this.{valueObject.BackingFieldName} = value;

			{callValidation}
		}}
	}}

    /// <summary>
    /// Backing field for the structural value. Don't use this field, instead use <see cref=""{valueObject.PropertyName}""/>.
	/// </summary>
	[Obsolete]
	private readonly {valueObject.TypeName} {valueObject.BackingFieldName};";
		}
		
		
		string? GetEnumerator()
		{
			var enumeratorCode = valueObject.GetEnumeratorCode();
			
			return enumeratorCode is null
				? null
				: @$"
	{enumeratorCode}
	IEnumerator IEnumerable.GetEnumerator()  => this.GetEnumerator();";
		}
	}
}
