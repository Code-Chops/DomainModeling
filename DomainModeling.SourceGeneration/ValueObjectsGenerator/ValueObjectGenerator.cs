using System.Collections.Immutable;
using System.Globalization;
using CodeChops.SourceGeneration.Utilities;
using Microsoft.CodeAnalysis.Diagnostics;

namespace CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration.ValueObjectsGenerator;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
	internal const string AttributeNamespace	= "CodeChops.DomainDrivenDesign.DomainModeling.Attributes";
	internal const string StringAttributeName	= "GenerateStringValueObject";
	internal const string IntegralAttributeName	= "GenerateIntegralValueObject";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{		
		var valueProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: ValueObjectSyntaxReceiver.CheckIfProbablyIsValueObjectToGenerate,
				transform: static (context, _) => ValueObjectSyntaxReceiver.GetModel((TypeDeclarationSyntax)context.Node, context.SemanticModel))
			.Where(static model => model is not null)
			.Collect()
			.Combine(context.AnalyzerConfigOptionsProvider);
		
		context.RegisterSourceOutput(source: valueProvider, action: static (context, valueProvider) => CreateSource(context, valueProvider.Left!, valueProvider.Right));
	}
	
	private static void CreateSource(SourceProductionContext context, ImmutableArray<ValueObject> models, AnalyzerConfigOptionsProvider configOptionsProvider)
	{
		foreach (var model in models)
		{
			var code = CreateSource(model);

			var fileName = model.Namespace is null 
				? model.Name 
				: $"{model.Namespace}.{model.Name}";
			
			fileName = FileNameHelpers.GetFileName(fileName, configOptionsProvider);
			
			context.AddSource(fileName, SourceText.From(code, Encoding.UTF8));
		}
	}

	private static string CreateSource(ValueObject data)
	{
		var integralObject = data as IntegralValueObject;
		var stringObject = data as StringValueObject;

		var backingFieldName = $"_value{new Random().Next(0, 9999)}";
		
		var code = $@"// <auto-generated />
#nullable enable
#pragma warning disable CS0612

using System;
using System.Collections;
using System.Globalization;
using System.Text.RegularExpressions;

{GetNamespaceDeclaration()}

/// <summary>
/// {GetComments()}
/// </summary>
{data.Declaration} : IValueObject, IComparable<{data.Name}>{GetInterfaces()}
{{
	{GetToString()}
	
	{GetComparison()}
	
	{GetEmptyInstance()}
	
	/// <summary>
    /// The primitive structural value. Use the primary constructor to set the backing field.
    /// </summary>
	private {data.TypeName} Value => this.{backingFieldName};

    /// <summary>
    /// Backing field for the structural value. Don't use this field, instead use <see cref=""Value""/>. 
	/// To set a value, use the primary constructor.
	/// </summary>
	[Obsolete]
	private readonly {data.TypeName} {backingFieldName};
	
	{GetLength()}
	
	public static implicit operator {data.TypeName}({data.Name} obj) => obj.Value;
	public static explicit operator {data.Name}({data.TypeName} value) => new(value);
	
	public {data.Name}({data.TypeName} value)
	{{
{GetIntegralValidation() ?? GetStringValidation()}
		
		this.{backingFieldName} = value;

		this.Validate();
	}}

	partial void Validate();

	{GetParameterlessConstructor()}	

	{GetEnumerator()}
}}

#pragma warning restore CS0612
#nullable restore
";

		return code;
		

		string? GetNamespaceDeclaration() => data.Namespace is null 
			? null 
			: $@"namespace {data.Namespace};";

		string GetComments() => integralObject is not null 
			? $@"Type {integralObject.TypeName}." 
			: $@"An {stringObject!.StringCaseConversion} {stringObject.StringFormat} string.";

		string? GetToString() => data.GenerateToString
			? "public override string ToString() => this.ToEasyString(new { this.Value });"
			: null;
		
		string? GetInterfaces()
		{
			if (stringObject is null) return null;
			
			var interfaces = new StringBuilder();
			if (stringObject.GenerateEnumerable) interfaces.Append(", IEnumerable<char>");
			if (stringObject.GenerateEmptyStatic) interfaces.Append($", IHasEmptyInstance<{data.Name}>");
			
			return interfaces.ToString();
		}

		string GetComparison()
		{
			var equals = stringObject is null || stringObject.CompareOptions == CompareOptions.None
				? null
				: $", StringComparison.{stringObject.CompareOptions}";
			var compareTo = equals is null
				? $"this.Value.CompareTo(other.Value)" 
				: $"String.Compare(this.Value, other.Value{equals})";
			
			return @$"
	public bool Equals({data.Name}? other) 
		=> {data.TypeName}.Equals(this.Value, other?.Value{equals});
	
	public int CompareTo({data.Name} other) 
		=> {compareTo};";
		}

		string? GetEmptyInstance() => data.GenerateEmptyStatic
			? $"public static {data.Name} Empty {{ get; }} = new({(stringObject is null ? $"default({data.TypeName})" : "\"\"")});"
			: null;

		string? GetLength() => stringObject is not null 
			? "public int Length => this.Value.Length;" 
			: null;

		string? GetStringValidation()
		{
			if (stringObject is null) return null;
			
			var validation = new StringBuilder();

			if (stringObject.StringFormat is not StringFormat.Default)
			{
				var formatRegex = stringObject.StringFormat switch
				{
					StringFormat.Alpha						=> "^[a-zA-Z]+$",
					StringFormat.AlphaWithUnderscore		=> "^[a-zA-Z_]+$",
					StringFormat.AlphaNumeric				=> "^[a-zA-Z0-9]+$",
					StringFormat.AlphaNumericWithUnderscore => "^[a-zA-Z0-9_]+$",
					_										=> throw new ArgumentOutOfRangeException(nameof(stringObject.StringFormat), stringObject.StringFormat, null)
				};

				validation.AppendLine($@"		if (Regex.IsMatch(value, ""{formatRegex}"", RegexOptions.Compiled)) throw new ArgumentException(""Invalid characters in {data.Name} of format {stringObject.StringFormat}. Value '{{value}}'."");");
			}
			
			if (stringObject.MinimumLength is not null)
				validation.AppendLine($@"		if (value.Length < {stringObject.MinimumLength}) throw new ArgumentException($""String of {data.Name} is shorter ({{value.Length}}) than {nameof(stringObject.MinimumLength)} {stringObject.MinimumLength}."");");
			
			if (stringObject.MaximumLength is not null)
				validation.AppendLine($@"		if (value.Length > {stringObject.MaximumLength}) throw new ArgumentException($""String of {data.Name} is longer ({{value.Length}}) than {nameof(stringObject.MaximumLength)} {stringObject.MaximumLength}."");");

			if (stringObject.StringCaseConversion is not StringCaseConversion.NoConversion)
				validation.AppendLine($"		value = value.To{stringObject.StringCaseConversion}();");

			return validation.ToString();
		}

		string? GetIntegralValidation()
		{
			if (integralObject is null) return null;

			var validation = new StringBuilder();

			if (integralObject.MinimumValue is not null)
				validation.AppendLine($@"		if (value < {integralObject.MinimumValue}) throw new ArgumentException($""{data.TypeName} of {data.Name} is smaller ({{value}}) than {nameof(integralObject.MinimumValue)} {integralObject.MinimumValue}."");");
			
			if (integralObject.MaximumValue is not null)
				validation.AppendLine($@"		if (value > {integralObject.MaximumValue}) throw new ArgumentException($""{data.TypeName} of {data.Name} is higher ({{value}}) than {nameof(integralObject.MaximumValue)} {integralObject.MaximumValue}."");");

			return validation.ToString();
		}

		string GetParameterlessConstructor()
		{
			return $@"
	[Obsolete(Error)]
	public {data.Name}() => throw new InvalidOperationException(Error);
	private const string Error = $""A value should be provided when initializing {data.Name}.""; 
";
		}
		
		string? GetEnumerator() => stringObject?.GenerateEnumerable == true
			? @"
	public IEnumerator<char> GetEnumerator() => this.Value.GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator()  => this.GetEnumerator();"
			: null;
		}
}
