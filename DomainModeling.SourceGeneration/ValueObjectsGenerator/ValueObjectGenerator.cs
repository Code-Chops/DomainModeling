using System.Collections.Immutable;
using CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration.ValueObjectsGenerator.Models;
using CodeChops.SourceGeneration.Utilities;
using Microsoft.CodeAnalysis.Diagnostics;

namespace CodeChops.DomainDrivenDesign.DomainModeling.SourceGeneration.ValueObjectsGenerator;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{		
		var valueProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: ValueObjectSyntaxReceiver.CheckIfProbablyIsValueObjectToGenerate,
				transform: static (context, _) => ValueObjectSyntaxReceiver.GetModel((TypeDeclarationSyntax)context.Node, context.SemanticModel))
			.Where(static model => model is not null)
			.Collect()
			.Combine(context.AnalyzerConfigOptionsProvider);
		
		context.RegisterSourceOutput(source: valueProvider, action: static (context, valueProvider) => CreateSource(context, valueProvider.Left!, valueProvider.Right));
	}
	
	private static void CreateSource(SourceProductionContext context, ImmutableArray<ValueObjectBase> models, AnalyzerConfigOptionsProvider configOptionsProvider)
	{
		try
		{
			foreach (var model in models)
			{
				var code = CreateSource(model, configOptionsProvider);
	
				var fileName = model.Namespace is null 
					? model.Name 
					: $"{model.Namespace}.{model.Name}";
				
				fileName = FileNameHelpers.GetFileName(fileName, configOptionsProvider);
				
				context.AddSource(fileName, SourceText.From(code, Encoding.UTF8));
			}
		}
		
		catch (Exception e)
		{
			var descriptor = new DiagnosticDescriptor(nameof(ValueObjectGenerator), "Error", $"{nameof(ValueObjectGenerator)} failed to generate due to an error. Please inform CodeChops (www.CodeChops.nl). Error: {e}", "Compilation", DiagnosticSeverity.Error, isEnabledByDefault: true);
			context.ReportDiagnostic(Diagnostic.Create(descriptor, null));

			context.AddSource($"{nameof(ValueObjectGenerator)}_Exception_{Guid.NewGuid()}", SourceText.From($"/*{e}*/", Encoding.UTF8));
		}
	}

	private static string CreateSource(ValueObjectBase data, AnalyzerConfigOptionsProvider configOptionsProvider)
	{
		if (!configOptionsProvider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace))
			rootNamespace = "global::";
		
		var code = $@"// <auto-generated />
#nullable enable
#pragma warning disable CS0612 // Is deprecated

{GetUsings()}
{GetNamespaceDeclaration()}

/// <summary>
/// {GetComment()}
/// </summary>
[StructLayout(LayoutKind.Auto)]
{GetObjectDeclaration()}
{{
{GetToString()}
{GetHashCode()}
{GetEquals()}
{GetComparison()}
{GetDefaultStatic()}
#pragma warning disable CS0618 // Member is deprecated
{GetProperty()}
{GetDefaultConstructor()}
#pragma warning restore CS0618 // Member is deprecated
{GetLengthOrCountCode()}
{GetCastCode()}
{GetForbiddenParameterlessConstructor()}	
{GetEmptyCustomValidation()}
{GetEnumerator()}
{GetExtraCode()}
}}

#pragma warning restore CS0612 // Is deprecated
#nullable restore
";

		return code;
		
		
		string GetUsings()
		{
			var namespaces = data.GetNamespaces().Union(new[]
			{
				"System",
				"System.Collections",
				"System.Collections.Immutable",
				"System.ComponentModel",
				"System.Diagnostics",
				"System.Diagnostics.CodeAnalysis",
				"System.Globalization",
				"System.Runtime.InteropServices",
				"System.Text.RegularExpressions",
				"CodeChops.DomainDrivenDesign.DomainModeling.Exceptions",
				"CodeChops.DomainDrivenDesign.DomainModeling.Validation",
				rootNamespace,
			});
			
			var namespaceUsings = namespaces
				.OrderBy(ns => ns.StartsWith("CodeChops"))
				.ThenBy(ns => ns)
				.Aggregate(new StringBuilder(), (sb, ns) => sb.AppendLine($"using {ns};"))
				.ToString();

			return namespaceUsings;
		}
		

		string? GetNamespaceDeclaration() => data.Namespace is null 
			? null 
			: $@"namespace {data.Namespace};";


		string GetComment()
		{
			return $@"{data.GetCommentsCode()}
/// Extends: <see cref=""{data.Name.Replace('<', '{').Replace('>', '}')}""/>.";
		}
		
		
		string? GetInterfaces()
		{
			if (data.ValueObjectType.IsRefLikeType) 
				return null;
			
			var interfaces = new StringBuilder(" : IValueObject");
			if (data.ConstructorIsPublic && data.UseValidationExceptions) interfaces.Append($", ICreatable<{data.Name}, {data.UnderlyingTypeName}>");
			if (data.GenerateComparison && data.GetCompareToCode() is not null) interfaces.Append($", IEquatable<{data.Name}>");
			if (data.GenerateStaticDefault) interfaces.Append($", IHasDefaultInstance<{data.Name}>");
			if (data.AddIComparable && data.GenerateComparison) interfaces.Append($", IComparable<{data.Name}>");
			if (data.GenerateEnumerable && data is IEnumerableValueObject enumerableValueObject) interfaces.Append($", IEnumerable<{enumerableValueObject.ElementTypeName}>");

			var extraInterfaces = data.GetInterfacesCode();
			if (extraInterfaces is not null) interfaces.Append($", {extraInterfaces}");
			
			return interfaces.ToString();
		}


		string GetObjectDeclaration()
		{
			var code = new StringBuilder();

			var declaration = data.ValueObjectType.GetObjectDeclaration();
			
			if (data.ValueObjectType.TypeKind == TypeKind.Struct)
				declaration = declaration.Replace("partial", "readonly partial");

			code.AppendLine($"{declaration} {data.ValueObjectType.GetTypeNameWithGenericParameters()}{GetInterfaces()}");

			return code.ToString();
		}

		
		string GetToString() => data.GenerateToString 
			? $@"	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{data.GetToStringCode()}" 
			: $@"	public override partial string ToString();";

		
		string? GetHashCode() => data.GenerateComparison
			? $@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{data.GetHashCodeCode()}" 
			: null;


		string? GetEquals()
		{
			if (!data.GenerateComparison) return null;

			var equalsCode = new StringBuilder($@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{data.GetEqualsCode()}
");

			if (!data.ValueObjectType.IsRecord)
				equalsCode.Append($@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{data.GetObjectEqualsCode()}
");

			return equalsCode.ToString();
		}

		string? GetComparison()
		{
			var equalityOperators = data.ValueObjectType.IsRecord
				? null
				: $@"[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator ==({data.Name} left, {data.Name} right) => left.{data.PropertyName} == right.{data.PropertyName};
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator !=({data.Name} left, {data.Name} right) => !(left == right);";
			
			if (!data.GenerateComparison) return equalityOperators;
			
			var compareToCode = data.GetCompareToCode();
			if (compareToCode is null) return equalityOperators;
			
			return $@"
	{equalityOperators}
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{compareToCode}

	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator <	({data.Name} left, {data.Name} right)	=> left.CompareTo(right) <	0;
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator <=	({data.Name} left, {data.Name} right)	=> left.CompareTo(right) <= 0;
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator >	({data.Name} left, {data.Name} right)	=> left.CompareTo(right) >	0;
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool operator >=	({data.Name} left, {data.Name} right)	=> left.CompareTo(right) >= 0;
";
		}
		
		
		string? GetDefaultStatic()
		{
			if (!data.GenerateStaticDefault) return null;
			
			return data.ForbidParameterlessConstruction 
				? $@"
	[DebuggerHidden]
	public static {data.Name} DefaultInstance {{ get; }} = new()
;"
				: $@"
	[DebuggerHidden]
	public static {data.Name} DefaultInstance {{ get; }} = new({data.GetDefaultValue()});
";
		}


		string GetProperty()
		{
			var error = $"Don't use this field, use the {data.PropertyName} property instead";

			return $@"
	/// <summary>
    /// Get the underlying structural value.
    /// </summary>
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{(data.PropertyIsPublic ? "public" : "private")} {data.UnderlyingTypeName} {data.PropertyName} => this.{data.BackingFieldName}{(data is DefaultValueObject ? null : $" ?? {data.GetDefaultValue()}")};

    /// <summary>
    /// Backing field for the structural value. {error} <see cref='{data.PropertyName}'/>.
	/// </summary>
	[Obsolete(""{error}."")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	private readonly {data.UnderlyingTypeName} {data.BackingFieldName} = {data.GetDefaultValue()}!;
".Trim();
		}

		string? GetLengthOrCountCode()
		{
			var code = data.GetLengthOrCountCode();

			return code is null
				? null
				: $@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{code}
";
		}
		
		
		string GetCastCode()
		{
			var code = new StringBuilder();
			
			code.AppendLine($@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static implicit operator {data.UnderlyingTypeName}({data.Name} {data.LocalVariableName}) => {data.LocalVariableName}.{data.PropertyName};");
			
			code.AppendLine($@"	
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static explicit operator {data.Name}({data.UnderlyingTypeName} {data.LocalVariableName}) => new({data.LocalVariableName});");
			
			var extraCastCode = data.GetExtraCastCode(); 
			
			if (extraCastCode is not null) code.AppendLine($@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{extraCastCode}");

			return code.ToString();
		}
		
		string GetDefaultConstructor()
		{
			var validationType = $"Validator<{data.ValueObjectType.GetTypeNameWithGenericParameters()}>";
			
			var validationArgument = data.UseValidationExceptions && !data.ValueObjectType.IsRefLikeType
				? $", {validationType}? validator = null"
				: null;

			var validationCode = new StringBuilder();

			if (validationArgument is null) 
				validationCode
					.Append("var validator = ")
					.AppendLine(data.ValueObjectType.IsRefLikeType 
						? $"new Validator(objectName: typeof({data.ValueObjectType.GetTypeNameWithGenericParameters()}).Name);" 
						: $"{validationType}.ThrowWhenInvalid;");
			else
				validationCode.AppendLine($"validator ??= {validationType}.ThrowWhenInvalid;");
					
			var index = rootNamespace.IndexOf(".Domain", StringComparison.Ordinal);
			
			var boundedContextName = index > 0 
				? rootNamespace.Substring(0, index).Split('.').Last()
				: "UnknownBoundedContextName";

			var errorCodeStart = $"{boundedContextName}_{data.Name.Replace('<', '_').Replace(">", "")}";
			var specificValidationCode = data.GetValidationCode(errorCodeStart)?.Trim();

			if (specificValidationCode is not null)
				validationCode.Append($@"
		validator
			{specificValidationCode};
");

			return $@"
	[DebuggerHidden] 
	{(data.ConstructorIsPublic ? "public" : "private")} {data.ValueObjectType.Name}({data.UnderlyingTypeName} {data.LocalVariableName}{validationArgument})
	{{	
		{validationCode}

		this.{data.BackingFieldName} = {data.LocalVariableName}{data.GetValueTransformation()};

		{(data.AddCustomValidation ? "Validate(validator);" : null)}
	}}

	[DebuggerHidden] 
	public static {data.ValueObjectType.GetTypeNameWithGenericParameters()} Create({data.UnderlyingTypeName} {data.LocalVariableName}{validationArgument}) 
		=> new({data.LocalVariableName}{(validationArgument is null ? null : ", validator")});";
		}


		string? GetForbiddenParameterlessConstructor()
		{
			if (!data.ForbidParameterlessConstruction) return null;
			
			var error = $"Don't use this empty constructor. A {data.UnderlyingTypeName} should be provided when initializing {data.Name}.";
			
			return $@"
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
	[Obsolete(""{error}"", true)]
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public {data.ValueObjectType.Name}() => throw new InvalidOperationException($""{error}"");
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor";
		}

		
		string? GetEmptyCustomValidation()
		{
			if (data.ValueObjectType.IsRefLikeType) 
				return null;
			
			return data.AddCustomValidation
				? $@"
	private partial void Validate(Validator validator);
" 
				: @$"
	/// <summary>
	/// It is possible that custom validation is implemented but the parameter has been accidentally set to false.
	/// Therefore this stub will give a design time error, because it conflicts with the implemented one.
	/// </summary>
	private void Validate(Validator validator)
	{{
	}}
";
		}
		
		string? GetEnumerator()
		{
			if (!data.GenerateEnumerable) return null;
			
			var enumeratorCode = data.GetEnumeratorCode();
			
			return enumeratorCode is null
				? null
				: @$"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{enumeratorCode}
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();";
		}


		string? GetExtraCode()
		{
			var code = data.GetExtraCode();
			
			return code is null
				? null
				: $@"
	[DebuggerHidden]
	[EditorBrowsable(EditorBrowsableState.Never)]
	{data.GetExtraCode()}
";
		}
	}
}
